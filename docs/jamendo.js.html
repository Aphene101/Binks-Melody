<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: jamendo.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: jamendo.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file jamendo.js
 * @description Jamendo API client + player/visualizer/control wiring and
 * playlist add/remove UI. This module:
 *  - searches Jamendo tracks,
 *  - renders results and dispatches "play-request" events,
 *  - manages the global audio player (play/pause/seek/next/prev),
 *  - draws a canvas-based bar visualizer,
 *  - provides add/remove to playlist choosers backed by Firestore,
 *  - exposes minimal globals for cross-page "Add to playlist" reuse.
 */

import { db, auth } from "./firebase.js";
import {
  collection,
  getDocs,
  doc,
  getDoc,
  updateDoc,
  deleteDoc,
  arrayUnion,
} from "firebase/firestore";

/**
 * Public Jamendo app client id.
 * @see https://developer.jamendo.com/v3.0
 * @type {string}
 */
const CLIENT_ID = "804bfeee";

const COVER_FALLBACK =
  "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8Xw8AAuMBgVdPxT8AAAAASUVORK5CYII=";

/**
 * @typedef {Object} JamendoTrack
 * @property {string} id
 * @property {string} name
 * @property {string} artist_name
 * @property {string} [album_image]
 * @property {string} [audio] - Stream URL (may be proxied before playback)
 * @property {string} [audiodownload] - Alternate audio URL provided by API
 */

/**
 * Currently authenticated Firebase user id (if any).
 * @type {string|null}
 */
let currentUserId = null;
auth.onAuthStateChanged((user) => {
  if (user) currentUserId = user.uid;
});

document.addEventListener("DOMContentLoaded", () => {
  /**
   * Listen for play requests fired by search results or playlist pages.
   * @event window#play-request
   * @property {{track: JamendoTrack, index: number, playlist: JamendoTrack[]}} detail
   */
  window.addEventListener("play-request", (e) => {
    const { track, index, playlist } = e.detail;
    console.log("Received play-request for:", track.name);
    currentTrack = track;
    playTrack(track.audio, track, index, playlist);
  });

  const player = document.getElementById("player");
  const toggleBtn = document.getElementById("player-toggle");
  const playBtn = document.getElementById("p-play");

  if (!player || !toggleBtn || !playBtn) {
    console.warn("Minimizer setup skipped: missing elements");
    return;
  }

  toggleBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    player.classList.toggle("minimized");
  });

  player.addEventListener("click", (e) => {
    if (!player.classList.contains("minimized")) return;
    if (!playBtn.contains(e.target)) {
      player.classList.remove("minimized");
    }
  });

  const addBtn = document.getElementById("p-add");
  if (addBtn) {
    addBtn.addEventListener("click", handleAddToPlaylist);
  }
});

/**
 * Song options popup (Add / Remove). Appended to &lt;body>.
 * Visibility toggled by adding/removing the "hidden" class.
 * @type {HTMLDivElement}
 */
const songPopup = document.createElement("div");
songPopup.className = "song-popup hidden";
songPopup.innerHTML = `
  &lt;div class="popup-item" id="addToPlaylistBtn">
    &lt;img src="${import.meta.env.BASE_URL}Media/Purple-Add-Icon.svg" alt="Add">
    &lt;span>Add to Playlist&lt;/span>
  &lt;/div>
  &lt;hr>
  &lt;div class="popup-item" id="removeFromPlaylistBtn">
    &lt;img src="${import.meta.env.BASE_URL}Media/Delete-Icon.svg" alt="Remove">
     &lt;span>Remove from Playlist&lt;/span>
  &lt;/div>
`;
document.body.appendChild(songPopup);

/**
 * Track selected in the UI (for add/remove actions).
 * @type {JamendoTrack|null}
 */
let currentTrack = null;

/**
 * Search Jamendo tracks by text query.
 * @async
 * @param {string} query - Free-text search.
 * @returns {Promise&lt;JamendoTrack[]>} Up to 10 results.
 */
async function searchTracks(query) {
  const url = `https://api.jamendo.com/v3.0/tracks/?client_id=${CLIENT_ID}&amp;format=json&amp;limit=10&amp;search=${encodeURIComponent(
    query
  )}`;
  const response = await fetch(url);
  const data = await response.json();
  return data.results;
}

const searchInput = document.querySelector(".search-input");
const sectionTitle = document.querySelector(".section-title");
const gridContainer = document.querySelector(".grid-container");
const resultsContainer = document.getElementById("search-results");

const audioPlayer = document.getElementById("player-audio");
const playIcon = document.getElementById("play-icon");
const seekEl = document.getElementById("p-seek");

const currentEl = document.getElementById("p-current");
const durationEl = document.getElementById("p-duration");

const playBtn = document.getElementById("p-play");
const prevBtn = document.getElementById("p-prev");
const nextBtn = document.getElementById("p-next");

/**
 * Active playlist (in-memory) and the index of the currently playing track.
 * @type {JamendoTrack[]}
 */
let currentPlaylist = [];
/** @type {number} */
let currentIndex = -1;

/**
 * WebAudio + visualizer state.
 * @type {AudioContext|undefined} audioCtx
 * @type {AnalyserNode|undefined} analyser
 * @type {MediaElementAudioSourceNode|undefined} source
 * @type {Uint8Array|undefined} dataArray
 */
let audioCtx, analyser, source, dataArray;

/**
 * Render a list of tracks into the search results container,
 * and wire interactions for playing and the 'â‹¯' song menu.
 * No-op if `resultsContainer` isn't on the page.
 * @param {JamendoTrack[]} tracks
 * @returns {void}
 */
function displayResults(tracks) {
  resultsContainer.innerHTML = "";

  tracks.forEach((track, index) => {
    const trackWrapper = document.createElement("div");

    const trackDiv = document.createElement("div");
    trackDiv.classList.add("song-item");

    trackDiv.innerHTML = `
        &lt;div class="song-left">
            &lt;div class="song-thumb">
            &lt;img src="${
              track.album_image || COVER_FALLBACK
            }" alt="Album Art" onerror="this.src='${COVER_FALLBACK}'">
            &lt;/div>
            &lt;div class="song-info">
            &lt;span class="song-title">${track.name}&lt;/span>
            &lt;span class="song-artist">${track.artist_name}&lt;/span>
            &lt;/div>
        &lt;/div>
        &lt;button class="song-menu">
            &lt;img class="more-icon" src="${
              import.meta.env.BASE_URL
            }Media/More-icon.svg">
        &lt;/button>
        `;

    trackDiv.querySelector(".song-left").addEventListener("click", () => {
      const event = new CustomEvent("play-request", {
        detail: { track, index, playlist: tracks },
      });
      window.dispatchEvent(event);
    });

    trackDiv.querySelector(".song-menu").addEventListener("click", (e) => {
      e.stopPropagation();
      currentTrack = track;

      const rect = e.currentTarget.getBoundingClientRect();
      songPopup.style.top = `${rect.bottom + window.scrollY}px`;
      songPopup.style.left = `${rect.left + window.scrollX}px`;
      songPopup.classList.remove("hidden");
    });

    trackWrapper.appendChild(trackDiv);

    const hr = document.createElement("hr");
    hr.classList.add("song-separator");
    trackWrapper.appendChild(hr);

    resultsContainer.appendChild(trackWrapper);
  });
}

document.addEventListener("click", (e) => {
  if (!songPopup.contains(e.target)) {
    songPopup.classList.add("hidden");
  }
});

/**
 * Open a bottom-sheet chooser to add the current track
 * to one of the user's playlists.
 * Requires the user to be authenticated.
 * @returns {Promise&lt;void>}
 */
async function handleAddToPlaylist() {
  songPopup.classList.add("hidden");
  if (!currentUserId || !currentTrack) return;

  const chooser = document.createElement("div");
  chooser.className = "playlist-chooser";

  const playlistsCol = collection(db, "users", currentUserId, "playlists");
  const snap = await getDocs(playlistsCol);

  if (snap.empty) {
    const none = document.createElement("div");
    none.className = "playlist-row";
    none.innerHTML = `&lt;p>No playlists found&lt;/p>`;
    chooser.appendChild(none);
  } else {
    snap.docs.forEach((pl, index) => {
      const row = document.createElement("div");
      row.className = "playlist-row";

      row.innerHTML = `
            &lt;div class="playlist-icon">&lt;/div>
            &lt;p>${pl.data().name || "Untitled Playlist"}&lt;/p>
            &lt;span class="add-icon">&lt;img src="${
              import.meta.env.BASE_URL
            }Media/Add-To-Playlist-icon.svg" alt="Add">&lt;/span>
            `;

      const iconEl = row.querySelector(".playlist-icon");
      const cover =
        pl.data().songs?.[0]?.album_image ||
        pl.data().songs?.[0]?.albumArt ||
        pl.data().songs?.[0]?.cover ||
        "";

      if (cover) {
        iconEl.style.backgroundImage = `url(${cover})`;
        iconEl.style.backgroundColor = "transparent";
        iconEl.style.backgroundSize = "cover";
        iconEl.style.backgroundPosition = "center";
      } else {
        iconEl.style.backgroundImage = "none";
      }

      row.addEventListener("click", async () => {
        await updateDoc(doc(db, "users", currentUserId, "playlists", pl.id), {
          songs: arrayUnion(currentTrack),
        });
        slideOutAndRemove(chooser);
      });
      chooser.appendChild(row);

      if (index &lt; snap.docs.length - 1) {
        const sep = document.createElement("hr");
        sep.className = "playlist-separator";
        chooser.appendChild(sep);
      }
    });
  }

  document.body.appendChild(chooser);

  chooser.classList.add("show");

  setTimeout(() => {
    document.addEventListener("click", () => slideOutAndRemove(chooser), {
      once: true,
    });
  }, 0);
}

/**
 * Minimal globals so other pages (e.g., playlist page) can reuse
 * the same chooser UI without duplicating logic.
 * @param {JamendoTrack} t
 */
window.__bmSetCurrentTrack = (t) => {
  currentTrack = t;
};
/** Trigger the add-to-playlist chooser for the current track. */
window.__bmAddToPlaylist = () => {
  handleAddToPlaylist();
};

/**
 * Remove a track from a specific playlist, supporting both
 * array-stored songs and subcollection-based storage.
 * @async
 * @param {string} uid - User UID.
 * @param {string} playlistId - Playlist doc id.
 * @param {JamendoTrack} track - Track to remove.
 * @returns {Promise&lt;void>}
 */
async function removeTrackFromPlaylist(uid, playlistId, track) {
  const playlistRef = doc(db, "users", uid, "playlists", playlistId);
  const snap = await getDoc(playlistRef);

  if (snap.exists() &amp;&amp; Array.isArray(snap.data().songs)) {
    const arr = snap.data().songs || [];
    const filtered = arr.filter(
      (s) => (s.id ?? s.audio) !== (track.id ?? track.audio)
    );
    await updateDoc(playlistRef, { songs: filtered });
  } else {
    if (track.id) {
      await deleteDoc(
        doc(db, "users", uid, "playlists", playlistId, "songs", track.id)
      );
    } else {
      const songsCol = collection(
        db,
        "users",
        uid,
        "playlists",
        playlistId,
        "songs"
      );
      const songsSnap = await getDocs(songsCol);
      const match = songsSnap.docs.find(
        (d) => (d.data().id ?? d.data().audio) === (track.id ?? track.audio)
      );
      if (match) await deleteDoc(match.ref);
    }
  }
}

/**
 * Open a remove-from-playlist chooser for the current track.
 * @async
 * @returns {Promise&lt;void>}
 */
async function handleRemoveFromPlaylist() {
  songPopup.classList.add("hidden");
  if (!currentUserId || !currentTrack) return;

  const chooser = document.createElement("div");
  chooser.className = "playlist-chooser";

  const playlistsCol = collection(db, "users", currentUserId, "playlists");
  const snap = await getDocs(playlistsCol);

  if (snap.empty) {
    const none = document.createElement("div");
    none.className = "playlist-row";
    none.innerHTML = `&lt;p>No playlists found&lt;/p>`;
    chooser.appendChild(none);
  } else {
    snap.docs.forEach((pl, index) => {
      const row = document.createElement("div");
      row.className = "playlist-row";
      row.innerHTML = `
        &lt;div class="playlist-icon">&lt;/div>
        &lt;p>${pl.data().name || "Untitled Playlist"}&lt;/p>
        &lt;span class="add-icon">&lt;img src="${
          import.meta.env.BASE_URL
        }Media/Delete-Icon.svg" alt="Remove">&lt;/span>
      `;

      const iconEl = row.querySelector(".playlist-icon");
      const cover =
        pl.data().songs?.[0]?.album_image ||
        pl.data().songs?.[0]?.albumArt ||
        pl.data().songs?.[0]?.cover ||
        "";
      if (cover) {
        iconEl.style.backgroundImage = `url(${cover})`;
        iconEl.style.backgroundColor = "transparent";
        iconEl.style.backgroundSize = "cover";
        iconEl.style.backgroundPosition = "center";
      } else {
        iconEl.style.backgroundImage = "none";
      }

      row.addEventListener("click", async () => {
        await removeTrackFromPlaylist(currentUserId, pl.id, currentTrack);
        slideOutAndRemove(chooser);
      });
      chooser.appendChild(row);

      if (index &lt; snap.docs.length - 1) {
        const sep = document.createElement("hr");
        sep.className = "playlist-separator";
        chooser.appendChild(sep);
      }
    });
  }

  document.body.appendChild(chooser);
  chooser.classList.add("show");

  /**
   * Animate out and remove the chooser.
   * @param {HTMLElement} element
   */
  function slideOutAndRemove(element) {
    element.classList.remove("show");
    element.classList.add("hide");
    element.addEventListener("animationend", () => element.remove(), {
      once: true,
    });
  }

  setTimeout(() => {
    document.addEventListener("click", () => slideOutAndRemove(chooser), {
      once: true,
    });
  }, 0);
}

document
  .getElementById("addToPlaylistBtn")
  .addEventListener("click", handleAddToPlaylist);
document
  .getElementById("removeFromPlaylistBtn")
  ?.addEventListener("click", handleRemoveFromPlaylist);

/**
 * Lazily initialize the WebAudio analyser and start the visualizer loop.
 * Safe to call more than once.
 * @returns {void}
 */
function initVisualizer() {
  const audioPlayer = document.getElementById("player-audio");
  if (!audioPlayer) return;
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    source = audioCtx.createMediaElementSource(audioPlayer);

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 256;

    const bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);

    source.connect(analyser);
    analyser.connect(audioCtx.destination);

    drawVisualizer();
  }
}

/**
 * Start playback for a given track and playlist, update player UI,
 * and ensure the visualizer is initialized.
 * @param {string} audioUrl - Raw Jamendo audio URL to proxy and play.
 * @param {JamendoTrack} track - Track metadata for UI.
 * @param {number} index - Index in `playlist`.
 * @param {JamendoTrack[]} playlist - The list being played.
 * @returns {void}
 */
function playTrack(audioUrl, track, index, playlist) {
  const audioPlayer = document.getElementById("player-audio");
  const songTitle = document.getElementById("p-title");
  const songArtist = document.getElementById("p-artist");
  const playIcon = document.getElementById("play-icon");
  const seekEl = document.getElementById("p-seek");
  const songThumb = document.getElementById("p-cover");

  if (
    !songTitle ||
    !songArtist ||
    !songThumb ||
    !playIcon ||
    !audioPlayer ||
    !seekEl
  ) {
    console.warn("Player elements not found");
    return;
  }

  songTitle.textContent = track.name;
  songArtist.textContent = track.artist_name;
  if (!track.album_image) {
    songThumb.src = COVER_FALLBACK;
  } else {
    songThumb.onerror = () => (songThumb.src = COVER_FALLBACK);
    songThumb.src = track.album_image;
  }
  playIcon.src = `${import.meta.env.BASE_URL}Media/Pause-icon.svg`;

  document.getElementById("player").classList.add("open");

  audioPlayer.pause();
  const u = new URL(audioUrl);
  const proxied = `https://jamendo-proxy.aphene-falcon.workers.dev${u.pathname}${u.search}`;
  audioPlayer.src = proxied;
  audioPlayer.load();

  currentPlaylist = playlist;
  currentIndex = index;

  seekEl.value = 0;

  initVisualizer();

  audioPlayer.addEventListener("canplay", function onCanPlay() {
    audioPlayer.removeEventListener("canplay", onCanPlay);
    audioPlayer.play().catch((error) => {
      console.warn("Playback failed:", error);
    });
  });
}

if (audioPlayer) {
  audioPlayer.addEventListener("loadedmetadata", () => {
    if (durationEl) durationEl.textContent = formatTime(audioPlayer.duration);
  });
}

// Update progress bar as song plays
if (audioPlayer) {
  audioPlayer.addEventListener("timeupdate", () => {
    if (audioPlayer.duration) {
      const pct = (audioPlayer.currentTime / audioPlayer.duration) * 100;
      if (seekEl) seekEl.value = pct;
      if (currentEl)
        currentEl.textContent = formatTime(audioPlayer.currentTime);
    }
  });
}

if (audioPlayer)
  audioPlayer.addEventListener("ended", () => {
    if (currentPlaylist.length > 0) {
      currentIndex = (currentIndex + 1) % currentPlaylist.length;
      const nextTrack = currentPlaylist[currentIndex];
      playTrack(nextTrack.audio, nextTrack, currentIndex, currentPlaylist);
    }
  });

// Seek when user drags progress bar
seekEl?.addEventListener("input", () => {
  if (!audioPlayer.duration) return;
  audioPlayer.currentTime = (seekEl.value / 100) * audioPlayer.duration;
});

if (playBtn &amp;&amp; audioPlayer &amp;&amp; playIcon) {
  playBtn.addEventListener("click", () => {
    if (audioPlayer.paused) {
      audioPlayer.play();
      playIcon.src = `${import.meta.env.BASE_URL}Media/Pause-icon.svg`;
      playIcon.alt = "Pause";
    } else {
      audioPlayer.pause();
      playIcon.src = `${import.meta.env.BASE_URL}Media/Play-icon.svg`;
      playIcon.alt = "Play";
    }
  });
}

/**
 * Format seconds to m:ss.
 * @param {number} seconds
 * @returns {string}
 */
function formatTime(seconds) {
  const m = Math.floor((seconds || 0) / 60);
  const s = Math.floor((seconds || 0) % 60);
  return `${m}:${s &lt; 10 ? "0" : ""}${s}`;
}

// Previous and Next Buttons
prevBtn?.addEventListener("click", () => {
  if (currentPlaylist.length > 0) {
    currentIndex =
      (currentIndex - 1 + currentPlaylist.length) % currentPlaylist.length;
    const track = currentPlaylist[currentIndex];
    playTrack(track.audio, track, currentIndex, currentPlaylist);
  }
});

nextBtn?.addEventListener("click", () => {
  if (currentPlaylist.length > 0) {
    currentIndex = (currentIndex + 1) % currentPlaylist.length;
    const track = currentPlaylist[currentIndex];
    playTrack(track.audio, track, currentIndex, currentPlaylist);
  }
});

// Listen for search input (only if this page has a search bar)
if (searchInput) {
  searchInput.addEventListener("input", async (e) => {
    const query = e.target.value.trim();
    if (query.length > 2) {
      const tracks = await searchTracks(query);
      displayResults(tracks);
      if (sectionTitle) sectionTitle.style.display = "none";
      if (gridContainer) gridContainer.style.display = "none";
      if (resultsContainer) resultsContainer.style.display = "block";
    } else {
      if (resultsContainer) resultsContainer.innerHTML = "";
      if (sectionTitle) sectionTitle.style.display = "";
      if (gridContainer) gridContainer.style.display = "";
      if (resultsContainer) resultsContainer.style.display = "none";
    }
  });
}

/**
 * Draw a rounded rectangle bar.
 * @param {CanvasRenderingContext2D} ctx
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {number} radius
 * @returns {void}
 */
function drawBar(ctx, x, y, width, height, radius) {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
  ctx.fill();
}

/**
 * Animation loop that reads analyser frequency data and draws bars
 * centered in the canvas. Safe to call once after `initVisualizer()`.
 * @returns {void}
 */
function drawVisualizer() {
  requestAnimationFrame(drawVisualizer);

  if (!analyser) return;

  analyser.getByteFrequencyData(dataArray);

  const canvas = document.getElementById("visualizer");
  const ctx = canvas.getContext("2d");

  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;

  const gap = 8;
  const barCount = 24;
  const step = Math.floor(dataArray.length / barCount);
  const barWidth = canvas.width / barCount - gap;

  const minHeight = 8;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const totalWidth = barCount * barWidth + (barCount - 1) * gap;
  const offsetX = (canvas.width - totalWidth) / 2;

  for (let i = 0; i &lt; barCount; i++) {
    const value = dataArray[i * step];
    const barHeight = Math.max((value / 255) * canvas.height, minHeight);

    ctx.fillStyle = "#C2CDB3";
    drawBar(
      ctx,
      offsetX + i * (barWidth + gap),
      canvas.height - barHeight,
      barWidth,
      barHeight,
      6
    );
  }
}

/**
 * Fetch popular tracks by Jamendo tag (genre) and normalize to `JamendoTrack[]`.
 * Returns only items that have an audio URL available.
 * @async
 * @param {string} tag - Jamendo `tags` value (e.g., "rock", "jazz").
 * @param {number} [limit=10] - Max number of tracks to return.
 * @returns {Promise&lt;JamendoTrack[]>}
 */
export async function getTopTracksByTag(tag, limit = 10) {
  const url = `https://api.jamendo.com/v3.0/tracks/?client_id=${CLIENT_ID}&amp;format=json&amp;limit=${
    limit + 6
  }&amp;tags=${encodeURIComponent(tag)}&amp;order=popularity_total&amp;include=musicinfo`;
  const res = await fetch(url);
  if (!res.ok) throw new Error("Jamendo tag fetch failed");
  const json = await res.json();
  const rows = json?.results || [];
  const tracks = rows
    .map((t) => ({
      id: t.id,
      name: t.name,
      artist_name: t.artist_name,
      album_image: t.album_image,
      audio: t.audio || t.audiodownload,
    }))
    .filter((t) => !!t.audio)
    .slice(0, limit);

  return tracks;
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Events</h3><ul><li><a href="window.html#event:play-request">play-request</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CLIENT_ID">CLIENT_ID</a></li><li><a href="global.html#audioCtx">audioCtx</a></li><li><a href="global.html#auth">auth</a></li><li><a href="global.html#createPlaylist">createPlaylist</a></li><li><a href="global.html#createStarterPlaylist">createStarterPlaylist</a></li><li><a href="global.html#currentIndex">currentIndex</a></li><li><a href="global.html#currentPlaylist">currentPlaylist</a></li><li><a href="global.html#currentPlaylistId">currentPlaylistId</a></li><li><a href="global.html#currentTrack">currentTrack</a></li><li><a href="global.html#currentUserId">currentUserId</a></li><li><a href="global.html#db">db</a></li><li><a href="global.html#displayResults">displayResults</a></li><li><a href="global.html#drawBar">drawBar</a></li><li><a href="global.html#drawVisualizer">drawVisualizer</a></li><li><a href="global.html#formatTime">formatTime</a></li><li><a href="global.html#getFriendlyErrorMessage">getFriendlyErrorMessage</a></li><li><a href="global.html#getTopTracksByTag">getTopTracksByTag</a></li><li><a href="global.html#handleAddToPlaylist">handleAddToPlaylist</a></li><li><a href="global.html#handleRemoveFromPlaylist">handleRemoveFromPlaylist</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#initVisualizer">initVisualizer</a></li><li><a href="global.html#loadGenrePlaylist">loadGenrePlaylist</a></li><li><a href="global.html#loadPlaylist">loadPlaylist</a></li><li><a href="global.html#newPlaylistBtn">newPlaylistBtn</a></li><li><a href="global.html#openMorePopup">openMorePopup</a></li><li><a href="global.html#playTrack">playTrack</a></li><li><a href="global.html#playlistsContainer">playlistsContainer</a></li><li><a href="global.html#popupMenu">popupMenu</a></li><li><a href="global.html#qp">qp</a></li><li><a href="global.html#removeTrackFromPlaylist">removeTrackFromPlaylist</a></li><li><a href="global.html#renderPlaylists">renderPlaylists</a></li><li><a href="global.html#renderSongs">renderSongs</a></li><li><a href="global.html#resolveToEmail">resolveToEmail</a></li><li><a href="global.html#searchTracks">searchTracks</a></li><li><a href="global.html#songPopup">songPopup</a></li><li><a href="global.html#usernameDisplay">usernameDisplay</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Mon Sep 08 2025 11:24:55 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
